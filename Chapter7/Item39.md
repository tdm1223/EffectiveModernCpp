# 항목 39. 단발성 사건 통신에는 void 미래 객체를 고려하라
- 특정 사건이 일어나야만 작업을 진행할 수 있는 비동기 실행 과제에게 그 사건이 발생했음을 알려주는 다른 과제를 두는 것이 유용한 경우가 있다.
  - 자료구조의 초기화, 계산 과정 중 특정 단계의 완료, 의미 있는 감지기 등이 그러한 사건이다.
- 어떤 종류의 사건이든 이러한 **스레드 간 통신을 처리하는 가장 나은 방법**은 무엇일까 ?

## 조건 변수
- 한 가지 명백한 방법은 **조건 변수**를 사용하는 것이다.
- 조건을 검출하는 과제를 **검출 과제**라고 하고 조건에 반응하는 과제를 **반응 과제**라고 부른다.
- **반응 과제**는 하나의 조건 변수를 기다리고 **검출 과제**는 사건이 발생하면 그 조건 변수를 통지하면 된다.
```cpp
std::condition_variable cv;   // 사건을 위한 조건 변수
std::mutex m;                 // cv와 함께 사용할 뮤텍스

// 검출 과제
...                           // 사건을 검출한다

cv. notify_one();             // 반응 과제에게 알린다

// 반응 과제
...                                       // 반응 준비
{                                         // 인계 영역을 연다
  ...
  {
    std::unique_lock<std::mutex> lk(m);   // 뮤텍스를 잠근다
    cv.wait(lk);                          // 통지를 기다린다
    ...
  }
  ...
}
```
- 사건 발생을 알려줄 반응 과제가 여러 개라면 `notify_one` 대신 `notify_all`을 사용하는 것이 적합하다.
- 코드는 잘 작동하는 것처럼 보이지만 뮤텍스를 사용한다는 아쉬운 점(코드에서 냄새가 난다라고 표현한다)이 있다.
  - 뮤텍스는 **공유 자료**에 대한 접근을 제어하는 데 쓰이나 검출 과제와 반응 과제에는 그런 접근 제어가 필요 없을 수도 있다.
- 따라서 조건 변수 접근방식에 뮤텍스가 필요하다는 점은 **설계에 문제가 있음을 암시**하는 악취라 할 수 있다.

### 반드시 처리해야할 문제점 두 가지
- 반응 과제가 `wait`를 실행하기 전에 검출 과제가 조건 변수를 통지하면 반응 과제가 멈추게(`hang`) 된다.
  - 반응 과제가 `wait`를 실행하기 전에 검출과제가 통지를 실행하면 반응과제는 통지를 놓히고 영원히 통지를 기다리게 된다.
- `wait` 호출문은 가짜 기상을 고려하지 않는다.
  - 조건 변수를 기다리는 코드가 조건 변수가 통지되지 않았는데도 깨어날 수 있다는 것은 스레드 적용 `API`에서 흔한 일이다.
  - 이런일을 **가짜 기상**이라고 부른다.
  - 가짜 기상 문제를 제대로 처리하려면 기다리던 조건이 정말로 발생했는지 확인해야 한다.
  - `C++`의 조건변수 `API`에서는 기다리던 조건을 판정하는 람다(또는 기타 함수 객체)를 `wait`에 넘겨줌으로써 간편하게 수행할 수 있다.
  ```cpp
  cv.wait(lk, []{ return 사건 발생 여부; });
  ```
  - 이러한 능력을 활용하려면 자신이 기다리던 조건이 **참인지를 반응과제가 판단**할 수 있어야 한다.
  - 지금까지 고려하던 예에서 반응 과제가 기다리는 조건은 **특정 사건의 발생**이며 그 발생 여부를 검출하는 것은 **검출 과제의 몫**이다.
  - 반응 과제로서는 자신이 기다리는 사건이 실제로 일어났는지 판단하지 못할 수도 있다.
- 과제간 통신을 조건 변수를 이용해서 수행하는 것이 적절한 경우가 많지만 지금 예는 그런 경우가 아니다.

### bool 플래그
- 그 다음 대안으로 **공유 bool 플래그**를 생각할 수 있다.
```cpp
std::atomic<bool> flag(false); // 공유 플래그

// 검출 과제
{
  ...                          // 사건을 검출한다
  flag = true;                 // 반응 과제에게 통지한다
}

// 반응 과제
{
  ...                          // 반응 준비
  while (!flag);               // 사건을 기다린다
  ...                          // 사건에 반응한다
}
```
- 반응 스레드에서는 `bool` 플래스를 폴링(주기적 점검)한다.
  - 플래그가 설정되어 있으면 자신이 기다리던 사건이 발생했다는 뜻이므로 실질적인 반응 행동을 수행한다.
- 뮤텍스를 사용할 필요가 없고 반응 과제가 폴링을 시작하기 전에 검출 과제가 플래그를 설정해도 문제가 없고 가짜 기상도 없다.
- 그러나 이런 장점을 반응 과제의 폴링 비용이 깎아 먹는다.
  - 플래그가 설정되길 기다리는 동안 반응 과제는 여전히 실행중으로 쓸데없는 자원 낭비를 한다.
- 이를 방지하기 위해서는 `wait`를 사용해야한다.

```cpp
std::condition_variable cv;
std::mutex m;

bool flag(false);

// 검출 과제
{
  ...                                   // 사건을 검출한다
  {
    std::lock_guard<std::mutex> g(m);   // g의 생성자에서 m을 잠근다
    flag = true;                        // 반응 과제에게 통지한다
  }
}
cv.notify_one();                        // g의 소멸자에서 m을 푼다

// 반응 과제
{
  ...                                   // 반응 준비
  {
    std::unique_lock<std::mutex> lk(m);
    cv.wait(lk, [] { return flag; });   // 가짜 기상을 방지하기 위해 람다 사용
    ...                                 // 사건에 반응한다(m은 잠긴 상태)
  }
  ...                                   // 계속 반응한다(m은 풀린 상태)
}
```
- 검출 과제가 통지하기 전에 반응 과제가 `wait`를 호출해도, 가짜 기상이 발생해도 잘 돌아간다.
- 지속적인 폴링도 일어나지 않는다.
- `mutex`를 사용해야 한다는 점과 `bool`변수까지 써야한다는 점이 깔끔하지 않다.
- 반응 과제에서 `wait`이 먼저 호출되어야 한다는 점은 변하지 않았다.

### std::promise
- 앞선 항목에서 살펴본 문제를 모두 해결하는 방법이다.
- 검출 과제에는 `std::promise` 객체를 하나 두고 반응 과제에는 그에 대응되는 **미래 객체**를 하나 둔다.
- 사건이 발생했음을 인식하면 검출 과제는 자신의 `std::promise`를 설정한다.
- 반응 과제는 자신의 미래 객체에 대해 `wait`를 호출해 둔 상태이고 `wait` 호출은 `std::promise`가 설정될 때까지 차단 된다.
- `std::promise`와 미래(`std::future`, `std::shared_future`) 모두 형식 매개변수를 요구하는 템플릿이다.
  - 지금은 딱히 전송할 자료가 없고 반응 과제는 미래 객체가 설정되었는지만 알면 된다.
  - 이런 상황에서 `std::promise`와 미래 템플릿에 필요한 것은 통신 채널을 통해서 전달할 자료가 없음을 뜻하는 형식이고 `void`가 존재한다.
  - 검출 과제는 `std::promise<void>`를 반응 과제는 `std::future<void>`나 `std::shared_future<void>`를 사용하면 된다.
```cpp
std::promise<void> p;

// 검출 과제
{
  ...
  p.set_value();
}

// 반응 과제
{
  ...
  p.get_future().wait();
  ...
}
```
- 플래그를 이용한 접근방식처럼 뮤텍스가 필요하지 안다.
- 반응 과제가 `wait`로 대기하기 전에 검출 과제가 자신의 `std::promise`를 설정해도 작동하며 가짜 기상도 없다.
- 조건 변수 기반 접근방식에서처럼 반응 과제는 `wait` 호출 후 진정으로 차단되므로 기다리는 동안 시스템 자원을 전혀 소모하지 않는다.
- 주의해야할 점은 [std::promise와 미래 객체 사이에는 공유 상태](/Chapter7/Item38.md)가 있으며 대체로 공유 상태는 동적으로 할당된다.
  - 힙 기반 **할당 및 해제 비용을 유발**한다고 가정해야 한다.
- 더 중요한 것은 `std::promise`를 **한 번만 설정**할 수 있다는 점이다. 
  - `std::promise`와 미래 객체 사이의 통신 채널은 여러번 사용할 수 없는 단발성 메커니즘이다.

### void 미래 객체
- 스레드를 한 번만 유보한다면(생성 시점과 해당 스레드 함수의 실행시점 사이에서) **void 미래 객체를 이용하는 설계**가 합리적인 선택이다.

```cpp
// void 미래 객체를 사용한 뼈대 코드
std::promise<void> p;

void react();                               // 반응 과제에 해당하는 함수

void detect()                               // 검출 과제에 해당하는 함수
{
  std::thread t([]                          // 스레드를 생성한다
                {
                  p.get_future().wait();    // 미래 객체가 설정될
                  react();                  // 때까지 t를 유보
                });
  ...                                       // t는 유보된 상태이다. react는 그 다음에 호출된다.

  p.set_value();                            // t의 유보를 푼다(그러면 react를 호출한다)

  ...                                       // 추가 작업을 수행

  t.join();                                 // t를 합류 불가능으로 만든다.
}
```

- `detect` 바깥의 모든 경로에서 `t`를 **합류 불가능**으로 만드는것이 중요하므로 `ThreadRAII` 같은 [RAII](/Chapter7/Item37.md) 클래스를 사용하는 것이 바람직하다.

```cpp
// RAII 클래승를 사용한 예
std::promise<void> p;

void react();                               // 반응 과제에 해당하는 함수

void detect()                               // 검출 과제에 해당하는 함수
{
  ThreadRAII tr(                            // RAII 객체 사용
    std::thread([]
                {
                  p.get_future().wait();
                  react();
                }),
    ThreadRAII::DtorAction::join
  );
  ...                                       // tr 내부의 스레드는 유보된 상태

  p.set_value();                            // tr 내부 스레드의 유보를 푼다
  ...
}
```

- 이전보다는 안전해보이지만 첫 `...`부분에서 예외가 발생하면 `p`에 대한 `set_value`호출이 일어나지 않으며 람다 안의 `wait` 호출은 계속해서 차단된다.
  - 람다를 실행하는 스레드가 완료되지 않는다.
- 코드의 첫 `...` 부분에서 예외가 방출되면 `tr`의 소멸자가 완료되지 않으므로 이 함수가 멈추게 된다.

### 코드 확장
- `ThreadRAII`를 사용하는 코드가 아닌 뼈대 코드에서 반응 과제 하나가 아니라 여러 개를 유보하고 풀도록 확장하는 것이 가능하다.
- `react` 코드에서 `std::future`대신 `std::shared_future`를 사용한다.
- `std::future`의 `share` 멤버 함수가 자신의 공유 상태에 대한 소유권을 `share`가 산출하는 `std::shared_future`객체에 넘겨준다는 점만 알면 된다.
```cpp
std::promise<void> p;

void detect()                                   // 이제는 여러 개의 반응 과제에 통지한다.
{
  auto sf = p.get_furue().share();              // sf의 형식은 std::shared_future<void>
  
  std::vector<std::thread> vt;                  // 반응 스레드들을 담는 컨테이너
  
  for (int i = 0; i < threadsToRun; ++i) {      // sf의 지역 복사본을 기다린다.
    vt.emplace_back([sf]{ sf.wait();
                          react(); });
  }
  
  ...                                           // 이 ...에서 예외가 발생하면 합류 가능한
                                                // std::thread들이 파괴되어서 프로그램이 종료된다.

  p.set_value();                                // 모든 스레드들의 유보를 푼다.
  ...
  
  for (auto& t : vt) {
    t.join();                                   // 모든 스레드들을 합류 불가능으로 만든다.
  }
}
```