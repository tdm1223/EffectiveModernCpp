# 항목 35. 스레드 기반 프로그래밍보다 과제 기반 프로그래밍을 선호하라
## 비동기적으로 함수를 실행하는 방법
### std::thread 객체를 생성하는 방법
- `std::thread` 객체를 생성해서 그 객체에서 함수를 실행한다.
- **스레드 기반 프로그래밍**(thread-based)에 해당한다.
```cpp
int doAsyncWork();
std::thread t(doAsyncWork);
```

### std::async를 넘겨주는 방법
- 실행하려는 함수를 `std::async`에 넘겨준다.
- **과제 기반 프로그래밍**(task-based)에 해당한다.
```cpp
int doAsyncWork();
auto future = std::async(doAsyncWork);
```

### 두 방식의 비교
- 대체로 과제 기반 접근 방식이 스레드 기반 접근 방식보다 우월하다.
- `doAsyncWork`가 반환값을 돌려주는데 스레드 기반 호출에서는 반환값에 접근할 방법이 없다.
  - `doAsyncWork`가 예외를 던지면 `std::terminate` 호출을 통해서 프로그래밍이 죽는다.
- 과제 기반 접근방식에서는 `std::async`가 돌려주는 미래 객체에 `get`이라는 멤버 함수를 통해 접근할 수 있다.
  - `get` 함수는 `doAsyncWork`가 예외를 방출한다면 예외에 접근할 수 있기 때문에 더 중요해진다.
- 과제 기반 접근 방식은 좀 더 높은 수준의 추상을 체현한다.
  - 프로그래머는 세부적인 스레드 관리에서 벗어날 수 있다.

## 동시적 C++ 소프트웨어에서 스레드
- 동시적 `C++` 소프트웨어에서 스레드는 세 가지 의미로 쓰인다.

### 하드웨어 스레드
- **실제 연산을 수행하는 스레드**를 하드웨어 스레드라고 부른다.
- `CPU` 코어 하나당 하나 이상의 하드웨어 스레드를 제공한다.

### 소프트웨어 스레드
- 운영체제가 하드웨어 스레드들에서 실행되는 모든 프로세서와 일정을 관리하는 데 사용하는 스레드이다.
- `OS` 스레드나 시스템 스레드라고도 한다.
- 대체로 하드웨어 스레드보다 많은 소프트웨어 스레드를 생성할 수 있다.
- 하나의 소프트웨어 스레드가 블로킹되면 다른 스레드를 실행시킨다.
- 제한된 자원이므로 시스템이 제공할 수 있는 것보다 많이 생성하려 하면 `std::system_error` 예외가 발생한다.
  - 스레드에서 실행하고자 하는 함수가 예외를 던질 수 없는 경우(`noexcept`)에도 마찬가지이다.

### std::thread
- `C++` 표준 라이브러리의 스레드이다.
- 하나의 `C++` 프로세스 안에서 `std::thread` 객체는 바탕 소프트웨어 스레드에 대한 핸들로 작용한다.
- `std::thread` 객체가 어떤 소프트웨어 스레드에도 대응 되지 않는다면 널 핸들을 나타낸다.

## 과다구독 문제
- 가용 스레드가 모자라지 않는다고 해도, 과다구독 때문에 문제가 발생할 수 있다.
- 과다 구독은 실행 준비가 된 **소프트웨어 스레드**가 **하드웨어 스레드**보다 많은 상황이다.
- 스레드가 늘어날수록 문맥 교환이 발생하는 상황이 많아 지고 문맥 교환은 시스템의 전반적인 스레드 관리 부담을 증가시킨다.
  - `CPU` 캐시의 히트율이 줄게 된다.
  - 다른 스레드가 사용할 캐시가 오염된다.
- 과다구독을 피하기는 어렵다.
  - 과다구독을 피하도록 응용 프로그램을 잘 조율해도 다른 종류의 컴퓨터에서 잘 작동하리라는 보장은 없다.
- 이러한 문제를 누군가에게 떠넘긴다면 문제는 간단해진다.

### 과다구독 문제의 해결
- `std::async`를 사용한다.
  - 스레드 관리의 책임을 `C++` 표준 라이브러리 구현자로 옮긴다.
  - 예외를 방출하지 않기 때문에 가용 스레드 부족 때문에 예외를 받을 가능성이 크게 줄어든다.
- `std::async`는 새 소프트웨어 스레드를 생성하지 않을수도 있다.
- 부하 불균형 문제가 발생할 수 있다.
- `GUI` 스레드의 반응성이 여전히 문제가 될 수 있다.
  - 스케줄러로서는 스레드 중 반응성이 좋아야 하는 스레드가 어떤 것인지 알 수 없다.
  - `std::launch::async`라는 시동 방침을 `std::async`에 넘겨주는것이 바람직하다.
  - [실행하고자 하는 함수가 실제로 현재 스레드와는 다른 스레드에서 실행된다.](/Chapter7/item36.md)
- 최신 스레드 스케줄러는 시스템 전역 스레드 풀을 이용해 과다구독을 피한다.
  - 작업 훔치기 알고리즘을 이용해서 부하를 하드웨어 코어들에 균형 있게 분산한다.

## 스레드를 직접 다루어야 하는 경우
- 아래 경우들은 흔치 않은 경우이며, 대부분의 경우에서는 스레드를 직접 다루는 대신 과제 기반 설계를 사용하는 것이 바람직하다.

### 바탕 스레드(소프트웨어 스레드) 적용 라이브러리의 API에 접근해야 하는 경우
- 일반적으로 `C++` 동시성 `API`는 저수준 플랫폼 고유 `API`를 이용해서 구현된다.
- 흔히 쓰이는 것은 `pthreads` 라이브러리나 `Windows` 스레드 라이브러리이다.
- 이런 `API`들은 `C++`보다 풍부한 기능을 제공한다.
- 바탕 스레드 적용 라이브러리의 `API`에 접근할 수 있도록 `std::thread`는 `native_handle`이라는 멤버 함수를 제공한다.
  - `std::async`가 돌려주는 `std::future`에는 이에 해당하는 기능이 없다.

### 응용 프로그램의 스레드 사용량을 최적화해야 하는, 그리고 할 수 있어야 하는 경우
- 하드웨어 특성들이 미리 정해진 컴퓨터에서 **유일하게 의미있는 프로세스로 실행될 서버 소프트웨어**를 개발한다면 이런 요구가 생길 수 있다.

### C++ 동시성 API가 제공하는 것 이상의 스레드 적용 기술을 구현해야 하는 경우
- 개발자가 `C++` 구현이 스레드 풀을 제공하지 않는 특정 플랫폼을 위해 스레드 풀을 직접 구현해야 하는 경우 이런 요구가 생길 수 있다.