# 항목 40. 동시성에는 std::atomic을 사용하고, volatile은 특별한 메모리에 사용하라
## std::atomic과 volatile
### atomic
- 프로그래머들이 종종 `volatile`과 혼동하는 `C++`의 기능은 `std::atomic`이다.
- 이 템플릿의 인스턴스는 다른 스레드들이 반드시 **원자적으로 인식하는 연산**들을 제공한다.
- `std::atomic` 객체가 성공적으로 생성되면 그 객체에 대한 연산은 뮤텍스로 보호되는 임계 영역 안에서 수행되는 것처럼 작동한다.
```cpp
std::atomic<int> ai(0); // ai를 0으로 초기화한다.
ai = 10;                // 원자적으로 ai를 10으로 설정한다.
std::cout << ai;        // 원자적으로 ai의 값을 읽는다.
++ai;                   // 원자적으로 ai를 증가한다(11이 된다.)
--ai;                   // 원자적으로 ai를 감소한다(10이 된다.)
```
- 이 문장들을 실행하는 동안 `ai`를 읽는 다른 스레드들이 보게 되는 값은 0, 10, 11 뿐이고 그 외의 값은 불가능하다.
- `std::cout` 문장에서 `ai`가 `std::atomic` 객체라는 점이 보장하는 것은 `ai`의 **읽기가 원자적**이라는 것뿐이다.
  - 전체 문장이 원자적으로 처리된다는 보장은 없다.
- `ai`의 값을 읽는 시점과 `operator<<`가 호출되어서 `ai`의 값이 표준 출력에 기록되는 시점 사이에 다른 스레드가 `ai`의 값을 수정할 수도 있다.
  - 이 점이 문장의 행동에 영향을 미치지는 않는다.
  - `int`에 대한 `operaotr<<`는 주어진 `int` 인수에 대한 **값 전달 매개 변수를 출력에 사용**하기 때문이다.
  - 따라서 애초에 `ai`에서 읽은 값이 출력된다.
- 증가 연산이나 감소 연산은 **읽기-수정-쓰기 연산**이지만 각각 원자적으로 수행된다.
- `std::atomic` 객체가 생성되면, 그 객체에 대한 모든 멤버 함수는 다른 스레드들에게 반드시 원자적으로 보인다.

### atomic의 복사, 이동 연산
- `std::atomic` 은 **복사**와 **이동 연산**을 지원하지 않는다.
- 원자적 연산을 하드웨어 수준에서 지원하지 않기에 표준 위원회는 복사 생성과 복사 할당을 지원하지 않기로 하였다.
- `std::atomic`의 멤버 함수 `load`와 `store`를 활용하여 복사를 하는 방법이 가능하다.
```cpp
std::atomic<int> y(x.load()); // x를 읽는다.
y.store(x.load());            // x를 다시 읽는다.
```

### volatile
- `volatile`을 사용하는 아래와 같은 코드는 **다중 스레드 문맥**에서 거의 아무것도 보장하지 않는다.
```cpp
volatile int vi(0); // vi를 0으로 초기화한다.
vi = 10;            // vi를 10으로 설정한다.
std::cout<< vi;     // vi의 값을 읽는다.
++vi;               // vi를 증가한다(11이 된다.)
--vi;               // vi를 감소한다(10이 된다.)
```
- 이 코드를 실행하는 동안 `vi`의 값을 다른 스레드들이 읽는다면 그 스레드들은 어떤 값이라도 볼 수 있다.
  - 이런 코드는 **미정의 행동**을 유발한다.
- 이 코드의 문장들은 `vi`를 **수정**하므로 그와 동시에 다른 스레드들이 `vi`를 읽는다면 뮤텍스로 보호되지 않는다.
  - 메모리에 기록자들과 판독자들이 동시에 접근하는 **자료 경쟁 상황**이 발생한다.

## atomic은 성공하지만 volatile은 실패하는 상황
- `atomic`은 성공하지만 `volatile`은 실패하는 상황이 읽기-수정-쓰기 연산(`RMW`)만있는것은 아니다.
- 한 과제가 중요한 값을 계산하고 둘째 과제가 그 값을 자신의 작업에 사용하는 경우가 있다.
- 첫 과제가 값을 다 계산했으면 그것을 둘째 과제에게 알려주어야 한다.
```cpp
std::atomic<bool> valAvailable(false);
auto imptValue = computeImportantValue(); // 값을 계산한다.
valAvailable = true;                      // 다른 과제에게 값이 준비되었음을 알린다.
```
- 프로그래머는 `imptValue` 배정이 반드시 `valAvailable` 배정보다 **먼저 일어나야 함**을 알 수 있다.
- 컴파일러는 두 배정문을 단지 **서로 독립적인 변수에 대한 두 배정**으로 볼 뿐이다.
  - 일반적인 규칙으로 서로 무관한 배정들의 순서를 컴파일러가 임의로 바꾸는 것은 적법한 일이다.
- 컴파일러가 문장들의 순서를 바꾸지 않는다고 해도 바탕 하드웨어가 바꿀 수도 있다.
  - 순서를 바꾸면 코드가 더 빨리 실행되는 경우가 있기 때문이다.

### 코드 재배치 제약
- `std::atomic`을 사용하면 코드의 순서 재배치에 대한 제약들이 생긴다.
- 소스 코드에서 `std::atomic` 변수를 기록하는 문장 이전에 나온 그 어떤 코드도 그 문장 이후에 실행되지 않아야 한다.
```cpp
auto imptValue = computeImportantValue(); // 값을 계산한다.
valAvailable = true;                      // 다른 과제에게 값이 준비되었음을 알린다.
```
- 컴파일러는 `imptValue`와 `valAvailable`의 **배정문들의 순서를 그대로 지켜야 한다.**
- 바탕 하드웨어 역시 순서대로 명령들을 실행하게 만들어야 한다.
- `valAvailable`을 `volatile`로 선언하면 **코드 재배치 제약**이 가해지지 않는다.
```cpp
volatile bool valAvailable(false);
auto imptValue = computeImportantValue();
valAvailable = true;                      // 다른 스레드들은 이 배정을 imptValue 배정 이전에 볼 수 있다.
```
- 컴파일러는 `imptValue` 배정과 `valAvailable` 배정의 순서를 바꿀 수 있다.
- 바탕 하드웨어에서 다른 코어들이 `valAvailable`의 변화를 `imptValue`의 변화 이전에 볼 가능성이 있는 기계어 코드를 산출할 수 있다.

## volatile이 유용한 경우
- 연산의 원자성을 보장하지 않는다는 점과 코드 재배치에 대한 제약이 충분하지 않다는 점은 `volatile`이 동시적 프로그래밍에 유용하지 않은 이유를 잘 말해준다.
- `volatile`은 `volatile`이 적용된 변수가 사용하는 메모리가 **보통의 방식으로 행동하지 않는다는 점**을 컴파일러에게 알려주는 역할을 한다.

### 보통 메모리
- 보통 메모리에는 메모리의 한 장소에 어떤 값을 기록하면 다른 어떤 값을 덮어쓰지 않는 한 그 **값이 유지**된다는 특성이 있다.
```cpp
int x;
auto y = x; // x를 읽는다.
y = x;      // x를 다시 읽는다. 컴파일러가 최적화할 수 있다.
```
- 컴파일러는 `y`에 대한 **할당문을 제거**해서 목적 코드를 최적화 할 수 있다.
- 보통 메모리에는 어떤 메모리 장소에 값을 기록한 후 한번도 읽지 않고 값을 다시 기록한다면 **첫 번째 기록은 제거할 수 있다는 특성**이 있다.
```cpp
x = 10; // x를 기록한다. 컴파일러가 제거할 수 있다.
x = 20; // x를 다시 기록한다.
```
- 컴파일러는 첫 문장을 제거할 수 있다.
- 이런 종류의 **남아도는 읽기**(남아도는 적재)들과 **불필요한 기록**(죽은 저장)들을 수행하는 코드를 사람이 작성할 가능성은 거의 없다.
- 컴파일러가 합당해 보이는 소스 코드들에 템플릿 인스턴스화와 인라인화, 순서 재배치 최적화들을 적용하고 나면 **남아도는 적재**와 **죽은 저장**이 드물지 않게 생겨난다.

### 특별한 메모리
- 만일 특별한 메모리에 해당하는 변수가 있다면 `volatile`로 선언해야 한다.
- 특별한 메모리 중에서 가장 흔히 접할 수 있는 것은 **메모리 대응 입출력**에 쓰이는 메모리이다.
```cpp
volatile int x;
auto y = x;      // x를 읽는다.
y = x;           // x를 다시 읽는다 (최적화로 제거할 수 없음)
x = 10;          // x를 기록한다(최적화로 제거할 수 없음)
x = 20;          // x를 다시 기록한다.
```
- `x`가 메모리에 대응된 입출력 장소에 해당하는 경우에는 정확히 이런식으로 행동해야 한다.
- 특별한 메모리를 다룰 때에는 **남아도는 적재**와 **죽은 저장**으로 보이는 연산들을 반드시 유지해야 한다.
  - 이런 종류의 작업에 `std::atomic`은 적합하지 않다.

## 결론
- `std::atomic`은 동시적 프로그래밍에 유용하나, 특별한 메모리의 접근에는 유용하지 않다.
- `volatile`은 특별한 메모리의 접근에 유용하나, 동시적 프로그래밍에는 유용하지 않다.
- 둘의 용도가 다르므로 **함께 사용**하는 것도 가능하다.
```cpp
volatile std::atomic<int> val;
```