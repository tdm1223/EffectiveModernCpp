# 항목 42. 삽입 대신 생성 삽입을 고려하라
## std::push_back
- `std::string` 객체들을 담는 컨테이너에 삽입 함수를 이용해서 새요소를 추가하는 상황이 있다.
- 컨테이너에 담긴 요소에 맞게 해당 삽입 함수에 넘겨주는 요소의 형식은 `std::string`이어야 하지만 항상 참이지는 않다.
```cpp
std::vector<std::string> vx;
vs.push_back("xyzzy");
```
- 이 컨테이너는 `std::string`들을 담지만 `push_back`을 통해서 컨테이너에 넘겨주려는 것은 **문자열 리터럴**이다.
- 문자열 리터럴은 `std::string` 객체가 아니며 `push_back`에 넘겨주는 인수는 컨테이너에 담긴 요소들의 형식과는 다르다.
- `std::vector`의 `push_back`은 **왼값**과 **오른값**에 대해 오버로딩 되어 있다.
```cpp
// C++11 표준 명세서
template<class T, classAllocator = allocator<T>>
class vector{
public:
  void push_back(const T& x); // 왼값을 삽입
  void push_back(T&& x);      // 오른값을 삽입
}
```
- 컴파일러는 형식 불일치를 인지하고 **문자열 리터럴**의 형식을 다음과 같이 변환한다.
```cpp
vs.push_back("xyzzy");
vs.push_back(std::string("xyzzy"));
```
- 컴파일러는 인수의 형식과 `push_back`이 받는 매개변수의 형식이 일치하지 않음을 인식한다.
- 형식 불일치를 해소하기 위해 컴파일러는 **임시 스트링 객체를 생성**하고 `push_back`에 전달하는 코드를 산출한다.

### push_back의 성능
- 효율적이지는 않다.
- 벡터 내부적으로 원소를 집어넣을때 **임시 스트링 객체**를 한 번 생성한다.
  - **임시 객체이므로 오른값**이다.
- `push_back`의 **오른값 오버로딩**으로 전달된다.
  - 오버로딩에서 임시 객체는 오른값 참조 매개변수에 묶인다.
  - `std::vector`를 위한 메모리 안에서 복사본이 생성된다(두 번째 `std::string` 생성)
  - 실제로 새 객체가 만들어진다.
- `push_back`이 반환된 즉시 임시 객체가 파괴되어서 `std::string` 소멸자가 실행된다.

## std::emplace_back
```cpp
vs.emplace_back("xyzzy"); // "xyzzy"를 이용해서 std::string을 vs안에 직접 생성한다.
```
- 주어진 인수를 이용해서 `std::vector`안에서 직접 `std::string`을 생성한다.
- 임시 객체는 관여하지 않는다.
- `push_back`을 지원하는 모든 표준 컨테이너는 `emplace_back`을 지원한다.
- 문자열 리터럴이 아닌 경우에도 `push_back`과 똑같은 역할을 하며 더 효율적으로 동작하기도 한다.
- 이와 같은 형식을 **생성 삽입**이라고 부른다.

## 생성 삽입
- 삽입 함수들은 삽입할 객체를 받지만 생성 삽입 함수는 **삽입할 객체의 생성자를 위한 인수들**을 받는다.
  - 이런 차이 덕분에 생성 삽입 함수들은 임시 객체의 생성과 파괴를 피한다.

### 생성 삽입의 효율성
- 항상 생성 삽입을 사용하면 되지 않을까라고 생각할 수 있지만 그렇지 않다.
- 삽입 함수가 더 빠르게 실행되는 상황이 존재한다.

## 생성 삽입의 성능이 삽입의 성능을 능가하는 조건
- 아래 세 가지 조건이 모두 성립한다면 거의 항상 **생성 삽입의 성능이 삽입의 성능을 능가**한다.

### 추가할 값이 컨테이너에 배정되는 것이 아니라 컨테이너 안에서 생성될때
- 위 예제의 경우(값이 "xyzzy"인 `std::string` 객체를 `std::vector vs`에 추가하는)가 해당된다.
- 컨테이너에 원소를 추가할 때 어떠한 방식으로 추가하느냐의 차이이다.
- 객체 생성을 통해 추가할 수도 있고, 이동 배정을 통해 추가될 수 있다.
- 이동 배정을 위해서는 항상 원본 객체가 필요해 임시 객체가 생성되어 생성 삽입의 장점이 사라지는 것이다.
- 노드 기반 컨테이너들은 거의 항상 삽입을 통해 추가한다.

### 추가할 인수 형식이 컨테이너가 담는 형식과 다를때
- 생성 삽입의 장점은 유연한 인터페이스로 전달된 인수 형식들이 컨테이너가 담는 형식과 달라도 **임시 객체의 생성과 파괴가 일어나지 않는 것**이다.
- 어떤 `컨테이너<T>`에 `T형식`의 **객체를 추가**할 때에는 **생성 삽입**이 **삽입**보다 빠를 이유가 없다.
  - 삽입 인터페이스에서도 임시 객체를 생성할 필요가 없기 때문이다.

### 컨테이너가 기존 값과의 중복 때문에 새 값을 거부할 우려가 별로 없을때
- 컨테이너가 **중복을 허용**하거나 추가할 값들이 대부분 **고유한 경우**에 해당한다.
- 중복 제한이 있는 경우 일반적으로 생성 삽입 구현은 **새 값으로 노드를 생성해서 기존 컨테이너 노드들과 비교**한다.
- 추가할 값이 컨테이너에 **없으면 노드를 컨테이너에 연결**한다.
- 추가할 값이 컨테이너에 있으면 생성 삽입이 취소되고 그 노드가 파괴된다.
  - **생성과 파괴 비용이 낭비**된다.
- 이런 노드들은 삽입 함수보다 생성 삽입 함수에서 더 자주 생성된다.

## 생성 삽입 사용시 추가로 고려할점
### 자원 관리
- 다음과 같은 컨테이너가 존재한다.
```cpp
std::list<std::shared_ptr<widget>> ptrs;
```
- **커스텀 삭제자**를 통해서 해제되어야 하는 객체 하나를 이 컨테이너에 추가하려고 한다.
- `std::make_shared`를 사용할 수 없기 때문에 커스텀 삭제자를 지정해서 `std::shared_ptr`를 생성한다.
- 이 경우 반드시 `new`로 얻은 `raw`포인터로 그것을 관리할 `std::shared_ptr` 객체를 생성해야 한다.

```cpp
// 커스텀 삭제자
void killWidget(Widget* pWidget);
```
- 삽입 함수를 이용하는 코드는 다음과 같다.
```cpp
ptrs.push_back(std::shared_ptr<Widget>(new Widget, killWidget));
ptrs.push_back({ new Widget, killWidget });
```
- 두가지 의미는 동일하고 어떤 방식이든 `push_back` 호출 전에 임시 `std::shared_ptr` 객체가 생성된다.
- `push_back`의 매개변수는 `std::shared_ptr`에 대한 참조이므로 그 매개변수가 참조할 `std::shared_ptr` 객체가 반드시 있어야 한다.
- `push_back` 함수를 수행하던 중 메모리가 부족해져 예외가 발생한다고 가정한다.
  - 예외가 발생하면 생성되었던 임시 객체 또한 소멸되며 메모리가 정상적으로 해제된다.

```cpp
ptrs.emplace_back(new Widget, killWidget);
```
- `emplace_back`을 호출할 경우 문제가 생긴다.
- `new Widget`으로 만들어진 `raw` 포인터가 `emplace_back`으로 **완벽 전달**된다.
- `emplace_back`은 새 값을 담을 목록 노드를 할당한다.
- 할당이 실패하고 메모리 부족 예외가 발생한다.
- 예외가 `emplace_back` 밖으로 전파되면서 힙에 있는 `Widget` 객체에 도달하는 유일한 수단인 `raw` 포인터가 사라진다.
- `Widget`의 **자원 누수**가 발생한다.
- 컨테이너를 다룰때는 효율성 보다 **예외 안전성**에 더 신경을 써야한다.

#### 문제의 해결
- 위와 같은 문제를 해결하기 위해서는 **외부에서 객체를 생성해서 함수로 전달**하는 방법으로 해결할 수 있다.
```cpp
std::shared_ptr<Widget> spw(new Widget, killWidget); // Widget 객체와 그것을 관리하는 spw 객체를 생성

ptrs.push_back(std::move(spw));                      // spw를 오른값으로 전달
ptrs.emplace_back(std::move(spw));
```
- 이 접근방식에는 `spw`의 **생성과 파괴 비용**이 발생한다.
- 삽입 대신 생성 삽입을 사용하는 동기가 컨테이너가 담는 형식의 임시 객체를 피하는 것이지만 자원 관리 객체를 컨테이너에 추가한다면 생성 삽입이 삽입 함수보다 더 나은 성능을 보일 가능성은 거의 없다.

### explicit 생성자들과의 상호 작용 방식
```cpp
std::vector<std::regex> regexes;

std::regex r = nullptr;         // 오류! 컴파일 안 됨
regexes.push_back(nullptr);     // 오류! 컴파일 안 됨

regexes.emplace_back(nullptr);  // 정상 동작
```
- 정규표현식들을 담는 컨테이너를 생성하였다.
- `const char*` 포인터를 받는 `std::regex` 생성자는 `explicit`으로 선언되어 있다.
- `emplace_back` 호출 시 지정한 `nullptr`는 `std::regex` 객체로 변환할 무엇이 아니라 `std::regex` 객체의 생성자에 전달할 인수이다.
- 컴파일러는 **암묵적 변환 요청으로 간주하지 않는다.**
- 아래 두 초기화 구문도 다른 결과를 낸다.
```cpp
std::regex r1 = nullptr;        // 컴파일 에러
std::regex r2(nullptr);         // 컴파일 성공
```
- r1을 초기화하는 데 쓰인 구문은 **복사 초기화**이다.
- r2를 초기화하는 데 쓰인 구문은 **직접 초기화**이다.
- `explicit` 생성자에서는 **복사 초기화**를 사용할 수 없지만 **직접 초기화**는 사용할 수 있다.
  - `r1`의 초기화 문장은 컴파일 되지 않지만 `r2`의 초기화 문장을 컴파일 된다.
- **생성 삽입**의 경우 **직접 초기화**를 사용하여 `explicit` 생성자를 지원한다.
- **삽입 함수**는 **복사 생성자**를 사용하므로 `explicit` 생성자를 지원하지 않는다.