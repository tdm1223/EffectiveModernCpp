# 항목 17. 특수 멤버 함수들의 자동 작성 조건을 숙지하라
## 특수 멤버 함수
- 특수 멤버 함수란 `C++`이 **스스로 작성하는 멤버 함수**들을 가리킨다.
- `C++98`에서는 **기본 생성자**, **소멸자**, **복사 생성자**, **복사 할당 연산자**가 있었다.
  - 명시적으로 선언되어 있지는 않지만 **함수를 사용하는 클라이언트 코드가 존재**할때 작성된다.
- 작성된 특수 멤버 함수들은 암묵적으로 `public`이고 `inline`이다.
- 가상 소멸자가 있는 기본 클래스를 상속하는 경우 파생 클래스의 소멸자를 가상으로 선언된다.
- `C++11` 에 오면서 두 가지의 특수 멤버 함수 **이동 생성자**와 **이동 할당 연산자**가 추가됐다.

## 이동 생성자와 이동 할당 연산자
```cpp
class Widget {
public:
    ...
    Widget(Widget&& rhs);             // 이동 생성자
    Widget& operator=(Widget&& rhs);  // 이동 할당 연산자
    ...
};
```
- 이동 연산들은 필요할 때에만 작성되며 작성되는 경우에는 클래스의 **비정적 자료 멤버들의 멤버별 이동**을 수행한다.
  - 이동 생성자는 주어진 매개변수 `rhs`의 비정적 자료 멤버 각각을 이용해서 클래스의 해당 자료 멤버들을 각각 이동 생성한다.
  - 이동 할당 연산자는 주어진 매개변수 `rhs`의 비정적 자료 멤버 각각을 클래스의 해당 자료 멤버들에게 각각 이동 할당한다.
- 이동이 활성화되지 않은 형식은 복사 연산들을 통해서 이동되기 때문에 이동 연산이 실제로 일어난다는 보장은 없다.
  - 더 자세한 내용은 [항목 23](/Chapter5/Item23.md)에 있다.

## 이동 연산과 복사 연산의 차이
### 복사 연산
- Case 1
```
복사 생성자 선언
복사 할당 연산을 사용하는 클라이언트 코드 작성

결과
복사 할당 연산자 자동 생성
```

- Case 2
```
복사 할당 연산자 선언
복사 생성자를 사용하는 클라이언트 코드 작성

결과
복사 생성자 자동 생성
```
- 두 복사 연산은 서로 **독립적**이다.
- `Case1`, `Case2` 모두 `C++98`, `C++11`에서 동일하다.

### 이동 연산
- Case 1
```
이동 생성자 선언
이동 할당 연산을 사용하는 클라이언트 코드 작성

결과
이동 할당 연산자를 생성하지 않음
```

- Case 2
```
이동 할당 연산자 선언
이동 생성자를 사용하는 클라이언트 코드 작성

결과
이동 생성자를 자동 생성하지 않음
```
- 두 이동 연산은 **독립적이지 않다**.
- 둘 중 하나를 선언하면 컴파일러는 다른 하나를 작성하지 않는다.

### 둘이 같이 있을 때
- Case 1
```
복사 연산 중 하나를 선언
이동 연산 사용하는 클라이언트 코드 작성

결과
이동 연산들이 작성되지 않음
```

- Case 2
```
이동 연산 중 하나를 선언
복사 연산 사용하는 클라이언트 코드 작성

결과
복사 연산들이 작성되지 않음
```
- 복사 연산을 하나라도 명시적으로 선언한 클래스에 대해서는 이동 연산들이 작성되지 않는다.
- 이동 연산을 하나라도 명시적으로 선언하면 컴파일러는 복사연산들을 **비활성화** 한다([삭제](/Chapter3/Item11.md)를 통해 비활성화한다.)

### 이동 연산 자동 생성 조건
- 아래 세 조건이 모두 만족하고 필요할 때에만 자동으로 작성된다.
  - 클래스에 그 어떤 **복사 연산**도 선언되어 있지 않다.
  - 클래스에 그 어떤 **이동 연산**도 선언되어 있지 않다.
  - 클래스에 **소멸자**가 선언되어 있지 않다.

### default 연산자
- 컴파일러가 자동으로 생성하기를 기대하였는데 컴파일러가 생성해주지 않는다면 의도치 않은 방향으로 프로그램이 동작할 수 있다.
  - 위와 같은 문제를 피하기 위해 `default`연산을 사용한다.
- `default`연산은 자동으로 생성되기를 원하는 함수를 **명시적으로 나타내는 방법**이다.
- 파생 클래스 객체를 조작하는 데 쓰이는 인터페이스를 정의하는 클래스에 유용한 경우가 많다.
- 직접 소멸자를 선언하면 이동 연산들의 자동 작성이 금지되는데 소멸자를 두면서 이동 연산을 지원하고 싶다면 이동 연산들에 `default`를 지정하면 된다.
```cpp
class Base {
public:
    virtual ~Base() = default;              // 소멸자를 가상으로
    
    Base(Base&&) = default;                 // 이동 지원
    Base& operator=(Base&&) = default;
    
    Base(const Base&) = default;            // 복사 지원
    Base& operator=(const Base&) = default;
    ...
};
```

## C++11에서 특수 멤버 함수들을 생성 규칙 정리
### 기본 생성자
- 클래스에 **사용자 선언 생성자**가 없는 경우에만 자동으로 생성된다.

### 소멸자
- `C++98`의 규칙들과 같고 유일한 차이점은 소멸자가 기본적으로 [noexcept](/Chapter3/Item14.md)이다.
- 기본적으로 작성되는 소멸자는 오직 **기본 클래스 소멸자가 가상일때에만 가상**이다.

### 복사 생성자
- 클래스에 **사용자 선언 복사 생성자가 없을 때**에만 자동으로 작성된다.
- 클래스에 이동 연산이 하나라도 선언되어 있으면 삭제된다.
- 사용자 선언 복사 할당 연산자나 소멸자가 있는 클래스에서 이 함수가 자동 작성되는 기능은 비권장이다.

### 복사 할당 연산자
- 클래스에 **사용자 선언 복사 할당 연산자가 없을 때**에만 자동으로 작성된다.
- 클래스에 이동 연산이 하나라도 선언되어 있으면 삭제된다.
- 사용자 선언 복사 생성자나 소멸자가 있는 클래스에서 이 함수가 자동 작성되는 기능은 비권장이다.

### 이동 생성자와 이동 할당 연산자
- 클래스에 사용자 선언 복사 연산들과 이동 연산들, 소멸자가 없을때에만 자동으로 생성된다.
