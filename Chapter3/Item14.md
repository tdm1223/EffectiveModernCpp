# 항목 14. 예외를 방출하지 않을 함수는 noexcept로 선언하라
- `C++98`에서 예외 명세 작성 시 프로그래머는 함수 바깥으로 전파되는 예외 형식들을 요약해야 했으며 함수의 구현을 수정하면 예외 명세도 바꾸어야 할 가능성이 생겼다.
  - 호출자가 원래의 예외 명세에 의존할 수 있기 때문에 예외 명세가 변하면 클라이언트 코드가 깨질 수 있다.
- `C++11`에서 함수 선언 시 그 함수가 **예외를 방출하지 않을 것**임을 명시할 때에는 `noexcept`라는 키워드를 사용한다.
- 함수를 `noexcept`로 선언할 것인지의 여부는 인터페이스 설계상의 문제이다.
- `noexcept`는 함수의 인터페이스의 일부이다.

## noexcept 적용의 장점
- 컴파일러가 **더 나은 목적 코드**를 산출할 수 있다.
- 함수를 호출했을때 호출자가 예외를 받게 되는 일이 결코 없음을 약속하는 표현방법은 두 가지이다.

```cpp
int f(int x) throw();   // C++98
int f(int x) noexcept;  // C++11
```
- `C++98` 에서는 예외 명세가 위반되면 호출스택이 함수를 호출한 지점에 도달할때까지 풀린다.
  - 그 후 몇가지 동작이 취해진 후 프로그램 실행이 종료된다.
- `C++11` 에서는 풀릴 수도 있고 풀리지 않을수도 있다.
  - 풀릴수도 있다는 것은 **컴파일러가 최적화를 시킬 가능성**이 있다는 것이다.

## 이동생성자와 push_back
```cpp
std::vector<Widget> vw;
Widget w;
vc.push_back(w);
```
- `std::vector`에 새 요소를 추가할 때 `std::vector`에 충분한 공간이 없을 수 있다.
  - `std::vector`는 더 큰 메모리 조각을 **새로 할당**하고 기존 메모리 조각의 요소들을 새 조각으로 **옮긴다**.
- `C++98`에서는 기존 메모리에서 새 메모리로 요소들을 일일이 복사하고 기존 메모리에 있는 객체들을 파괴함으로써 요소 옮기기를 수행했다.
  - `push_back`은 강한 예외 안전성을 보장할 수 있었다.
  - 요소들을 복사하는 도중에 예외가 전져져도 `std::vector`의 상태는 변하지 않는다.
- `C++11`에서는 요소들의 **복사를 이동으로 대체**하는 것이 자연스러운 방식이다.
  - `push_back`의 예외 안전성 보장이 위반될 수 있다.
  - `push_back`을 하던 도중 에러가 발생하면 먼저 이동이 완료된 객체들을 다시 복원해야하는데 복원이 불가능할 수도 있다.
- `STL`에서는 **가능하면 이동하되 필요하면 복사한다**는 전략을 사용한다.
  - 이를 판단하는 기준이 바로 `noexcept`이다.
- 이동 생성자에 `noexcept`가 선언되어 있다면 이동 생성자를 호출하고 그렇지 않다면 복사 생성자를 호출한다.

## noexcept가 선언되어 있는 함수
- 예외를 전혀 방출하지 않는 것이 자연스러운 함수들도 있으며 `noexcept`로 선언하면 최적화에 큰 도움이 되는 함수들도 많다.
  - 예로는 이동 연산들과 `SWAP`이 있다.
- `noexcept`로 선언하는 것이 중요한 일부 함수들은 기본적으로 `noexcept`로 선언된다.
- 기본적으로 메모리 해제 함수와 모든 소멸자들은 암묵적으로 `noexcept`이다.
  - `noexcept`로 선언할 필요가 없다.
- 소멸자가 암묵적으로 `noexcept`로 선언되지 않는 유일한 경우
  - **예외 방출 가능성**을 명시적으로 밝힌 소멸자를 가진 형식의 자료 멤버가 클래스에 있을때 뿐이다.

## 넓은 계약과 좁은 계약
- 넓은 계약을 가진 함수는 **전제조건이 없는 함수**를 말한다.
- 넓은 계약을 가진 함수는 프로그램의 상태와 무관하게 호출할 수 있으며, 호출자가 전달하는 인수들에 어떤 제약도 가하지 않는다.
- 넓은 계약 함수는 미정의 행동을 보이지 않는다.
- 넓은 계약을 가진 함수를 작성하는 경우 그 함수가 예외를 던지지 않음을 알고 있다면 ?
  - 함수를 `noexcept`로 선언하면 된다.

## noexcept 사용시 주의할 점
```cpp
void setup();
void cleanup();

void doWork() noexcept
{
    setup();
    ...
    cleanup();
}
```
- `noexcept`로 선언되어 있지 않은 `setup`과 `cleanup`과 두 함수를 호출하는 `doWork` 는 `noexcept`로 되어 있다.
- `setup`과 `cleanup` 이 예외를 발생시킬 수 있는데 `doWork`가 `noexcpet`인 것은 모순되어 보인다.
  - `noexcept`로 선언되어 있지는 않지만 실제로는 예외를 절대로 던지지 않을 수도 있다.
- C에서 옮겨온 라이브러리들의 경우 `noexcept`로 선언되어 있지 않기 때문에 컴파일러는 경고 메시지를 표시하지 않는다.